【hashlib模块】
用于加密相关的操作，3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法

import hashlib

m = hashlib.md5()
m.update(b'hello')
print(m.hexdigest())
m.update(b"It's me")
print("m:  ", m.hexdigest())
m2 = hashlib.md5(b"helloIt's me")
print("m2: ", m2.hexdigest())

注：md5无法解密，网络上的解密是通过装库的方式实现的（通过生成好的MD5值配对）

s = hashlib.sha256()
s.update(b'admin')
print(s.hexdigest())
s.update('汉字处理方式'.encode(encoding='utf-8'))
print("s: ", s.hexdigest())

【hmac模块】
内部对我们创建 key 和内容 再进行处理然后再加密
散列消息鉴别码，简称HMAC，是一种基于消息鉴别码MAC（Message Authentication Code）的鉴别机制。
使用HMAC时,消息通讯的双方，通过验证消息中加入的鉴别密钥K来鉴别消息的真伪；

一般用于网络通信中消息加密，前提是双方先要约定好key,就像接头暗号一样，然后消息发送把用key把消息加密，
接收方用key ＋ 消息明文再加密，拿加密后的值 跟 发送者的相对比是否相等，这样就能验证消息的真实性，及发送者的合法性了。

import hmac

h = hmac.new(b"key", 'message可有汉字'.encode(encoding='utf-8'))
print(h.hexdigest())


【logging模块】
日志处理模块（屏幕显示、文件保存、日志分割保存、过滤日志）

（1）写文件
import logging

logging.basicConfig(filename='test.log', level=logging.DEBUG,
                    format="%(asctime)s %(module)s:%(lineno)d [%(levelname)s] %(message)s",
                    datefmt='%Y-%m-%d %H:%M:%S')

logging.debug('test debug')
logging.info('test info')
logging.warning('test warning')
logging.error('test error')
logging.critical('test critical')

（2）输出到控制台（默认warning）
import logging

logging.debug('test debug')
logging.info('test info')
logging.warning('test warning')
logging.error('test error')
logging.critical('test critical')

（3）控制台和文件中都存在
import logging

logger = logging.getLogger('TEST-LOG')
logger.setLevel(logging.DEBUG)

ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

fh = logging.FileHandler("access.log")
fh.setLevel(logging.WARNING)

ch_formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')

fh_formatter = logging.Formatter(
    '%(asctime)s - %(name)s: %(lineno)s - %(levelname)s - %(message)s')

ch.setFormatter(ch_formatter)
fh.setFormatter(fh_formatter)

logger.addHandler(ch)
logger.addHandler(fh)

logger.debug('debug message')
logger.info('info message')
logger.warn('warn message')
logger.error('error message')
logger.critical('critical message')

（4）日志文件切割：根据时间或文件大小
import logging

from logging import handlers
import time

logger = logging.getLogger(__name__)

log_file = "timelog.log"

按照10字节分割，保存3个备份
fh = handlers.RotatingFileHandler(filename=log_file,maxBytes=10,backupCount=3)

按照时间5秒分割
fh = handlers.TimedRotatingFileHandler(filename=log_file,when="S",interval=5,backupCount=3)

formatter = logging.Formatter('%(asctime)s %(module)s:%(lineno)d %(message)s')

fh.setFormatter(formatter)

logger.addHandler(fh)

logger.warning("test1")
time.sleep(2)
logger.warning("test12")
time.sleep(2)
logger.warning("test13")
logger.warning("test14")
time.sleep(2)
logger.warning("test15")
logger.warning("test16")


【re模块】（正则表达式）
字符类操作：查找、替换、分割

（1）常用正则表达式符合
'.'     默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行
'^'     匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r"^a","\nabc\neee",flags=re.MULTILINE)
'$'     匹配字符结尾，或e.search("foo$","bfoo\nsdfsf",flags=re.MULTILINE).group()也可以
'*'     匹配*号前的字符0次或多次，re.findall("ab*","cabb3abcbbac")  结果为['abb', 'ab', 'a']
'+'     匹配前一个字符1次或多次，re.findall("ab+","ab+cd+abb+bba") 结果['ab', 'abb']
'?'     匹配前一个字符1次或0次
'{m}'   匹配前一个字符m次
'{n,m}' 匹配前一个字符n到m次，re.findall("ab{1,3}","abb abc abbcbbb") 结果'abb', 'ab', 'abb']
'|'     匹配|左或|右的字符，re.search("abc|ABC","ABCBabcCD").group() 结果'ABC'
'(...)' 分组匹配，re.search("(abc){2}a(123|456)c", "abcabca456c").group() 结果 abcabca456c
 
 
'\A'    只从字符开头匹配，re.search("\Aabc","alexabc") 是匹配不到的
'\Z'    匹配字符结尾，同$
'\d'    匹配数字0-9
'\D'    匹配非数字
'\w'    匹配[A-Za-z0-9]
'\W'    匹配非[A-Za-z0-9]
'\s'     匹配空白字符、\t、\n、\r , re.search("\s+","ab\tc1\n3").group() 结果 '\t'
'(?P<name>...)' 分组匹配 re.search("(?P<province>[0-9]{4})(?P<city>[0-9]{2})(?P<birthday>[0-9]{4})","371481199306143242").groupdict("city") 
结果{'province': '3714', 'city': '81', 'birthday': '1993'}

（2）最常用的匹配语法
re.match 从头开始匹配
re.search 匹配包含
re.findall 把所有匹配到的字符放到以列表中的元素返回
re.split 以匹配到的字符当做列表分隔符
re.sub      匹配字符并替换

（3）反斜杠的困扰
与大多数编程语言相同，正则表达式里使用"\"作为转义字符，这就可能造成反斜杠困扰。
假如你需要匹配文本中的字符"\"，那么使用编程语言表示的正则表达式里将需要4个反斜杠"\\\\"：
前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。
Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r"\\"表示。
同样，匹配一个数字的"\\d"可以写成r"\d"。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。

（4）仅需轻轻知道的几个匹配模式
re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）
M(MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图）
S(DOTALL): 点任意匹配模式，改变'.'的行为

【subprocess模块】


【开发一个简单的python计算器】
实现加减乘除及拓号优先级解析

用户输入 1 - 2 * ( (60-30 +(-40/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) - (-4*3)/ (16-3*2) )等类似公式后，
必须自己解析里面的(),+,-,*,/符号和公式(不能调用eval等类似功能偷懒实现)，
运算后得出结果，结果必须与真实的计算器所得出的结果一致

hint:
re.search(r'\([^()]+\)',s).group()
'(-40/5)'