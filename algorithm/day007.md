### 树 ###
- 树是一种数据结构，比如目录结构。
- 树是一种可以递归定义的数据结构。
- 树是由n个节点组成的集合。
	- 若n=0， 那这是一颗空树。
	- 若n>0，那存在1个节点作为树的根节点，其他节点可以分m个集合，每个集合本身又是一颗树。
- 概念
	- 根节点
	- 叶子节点
	- 树的深度（高度）
	- 树的度
	- 孩子节点
	- 父节点
	- 子树

### 二叉树 ###
特殊且常用的树

- 二叉树：度不超过2的树（节点最多有两个叉）
- 满二叉树
- 完全二叉树
- 二叉树的存储方式
	- 链式存储方式
	- 顺序存储方式（列表）
	- 父节点和左孩子节点的编号下标有什么关系？
		- i~2i+1
	- 父节点和右孩子节点的编号下标有什么关系？
		- i~2i+2
- 小结
	- 二叉树是度不超过2的树
	- （完全）二叉树可以用列表来存储，通过规律可以从父亲找到孩子，或从孩子找到父亲

### 堆排序 ###
- 堆
	- 大根堆：一颗完全二叉树，满足任一节点都比其孩子节点大
	- 小根堆：一颗完全二叉树，满足任一节点都比其孩子节点小
- 当根节点的左右子树都是堆时，可以通过一次向下的调整来将其变换成一个堆。
- 堆排序过程
	1. 建立堆
	2. 得到堆顶元素，为最大元素
	3. 去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。
	4. 堆顶元素为第二大元素。
	5. 重复步骤3，直到堆变空。

### 编程 ###
	def shift(data, low, high):
		i = low
		j = 2*i + 1
		tmp = data[i]
		while j <= high:	# 孩子在堆里
			if j+1 <= high and data[j] < data[j+1]: #右孩子比左孩子大
				j += 1 # 指向右孩子
			if data[j] > tmp: #孩子比最高领导大
				data[i] = data[j] # 孩子当领导
				i = j	# 孩子成为新父亲
				j = 2*i +1	#新孩子
			else:
				break
		data[i] = tmp
	
	def heap_sort(data):
		n = len(data)
		# 建堆
		for i in range(n//2-1, -1, -1):
			shift(data, i, n-1)
		for i in range(n-1, -1, -1): # i指向堆的最后
			data[0], data[i] = data[i], data[0]
			shift(data, 0, i-1)		# 调整出新领导