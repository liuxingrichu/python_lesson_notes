# 路由系统（URL) #
- 一对一
	- url(r'^home', views.Home.as_view()) 对应类
	- url(r'^detail', views.detail) 对应函数
- 一对多
	- url(r'^detail-(\d+).html', views.detail),
	- url(r'^detail-(\d+)-(\d+).html', views.detail) 形参位置顺序影响业务逻辑
	- url(r'^detail-(?P<nid>\d+)-(?P<uid>\d+).html', views.detail) 推荐
###		
		def detail(request, *args, **kwargs):
			# kwargs 以字典形式取值
    		detail_info = USER_DICT.get(kwargs.get("nid"))
			# args 以元组形式取值
    		detail_info = USER_DICT.get(args[0])
			
		def detail(request, nid, uid):
    		detail_info = USER_DICT.get(nid)			

### 客户端访问形式一：http://127.0.0.1:8000/detail?nid=2
默认页面是动态的	
		
	urls.py
		url(r'^detail', views.detail),
		url(r'^login', views.login),
	
	views.py
		USER_DICT={
		    "1":{"name": "root1", "email": "root1@163.com"},
		    "2":{"name": "root2", "email": "root2@163.com"},
		    "3":{"name": "root3", "email": "root3@163.com"},
		    "4":{"name": "root4", "email": "root4@163.com"},
		}
		
		def detail(request):
		    nid = request.GET.get("nid")
		    detail_info = USER_DICT.get(nid)
		    return render(request, "detail.html", 	{"detail_info":detail_info})
	
		def index(request):
			return render(request, 'index.html', {"user_dict": USER_DICT})
	
	index.html
		<ul>
	        {% for k, v in user_dict.items %}
	            <li><a target="_blank" href="/detail?nid={{ k }}">{{ v.name }}</a></li>
	        {% endfor %}
	    </ul>
	
	detail.html
		<body>
		    <h1>详细信息</h1>
		    <h6>用户名：{{ detail_info.name }}</h6>
		    <h6>邮箱：{{ detail_info.email }}</h6>
		</body>

### 客户端访问形式二：http://127.0.0.1:8000/detail-1-10.html
默认页面是静态的

	views.py
		这里要求与urls对应关系的参数个数一致
		def detail(request, nid, uid):
		    detail_info = USER_DICT.get(nid)
		    return render(request, "detail.html", {"detail_info": detail_info})

		若参数不确定时，可以写成
		def detail(request, *args, **kwargs):
    		pass
	
	urls.py
		url(r'^detail-(?P<nid>\d+)-(?P<uid>\d+).html', views.detail)
	
	index.html
		<ul>
	        {% for k, v in user_dict.items %}
	            <li><a target="_blank" href="/detail-{{ k }}.html">{{ v.name }}</a></li>
	        {% endfor %}
    	</ul>	

	detail.html 同上			

	
		
----------	
# 视图 #
		request.GET
		request.POST
		request.FILES（文件操作）
		
		FBV function base view
			urls.py 
				index -> 函数名
				url(r'^login', views.login),
				请求来了，执行函数名对应的方法

			views.py
				def func(request):
					pass

		CBV	class base view
			urls.py 
				home -> 类
				url(r'^home', views.Home.as_view()),
					注：as_view()为固定写法
				请求来了，执行类中具体的方法
			
			views.py
				from django.views import View

				class Home(View):
				    def dispatch(self, request, *args, **kwargs):
				        print("before")
				        result = super(Home, self).dispatch(request, *args, **kwargs)
				        print("after")
				        return result
				
				    def get(self, request):
				        print(request.method)
				        return render(request, 'home.html')
				
				    def post(self, request):
				        print(request.method)
				        return render(request, 'home.html')
		
		装饰器



----------	
# 模板 #
	

----------
# ORM操作 #
		select * from tb where id>1
		# 对应关系
		modles.tb.objects.filter(id__gt=1)
		modles.tb.objects.filter(id=1)
		modles.tb.objects.filter(id__lt=1)

----------
# 默认数据交互规则 #
- GET: 获取数据
	- 浏览器默认方法
	- 将输入的内容，填充到url中，url上内看到填写内容，再发放到服务端
- POST：提交数据
	- 将输入内容，填充到body中，再发放到服务端
- GET方法和POST方法
	- get方法和post方法传输的内容，都可以通过抓包方式，获取内容
    - 不存在，那种方式更安全之说。
- PUT
- DELETE
- HEAD
- OPTION


----------
# 获取用户提交信息 #

- 输入框
	- request.POST.get("username")

- 单选框
	- request.POST.get("gender")

- 多选框
	- request.POST.getlist("favor")
- select
	- 默认单选
		- request.POST.get("city")
	- 有multiple，可多选
		- request.POST.getlist("city")
- 文件
form 表单头需要添加 enctype="multipart/form-data"
	- 文件名
		- obj.name
	- 文件内容(上传文件)
	### 
		obj = request.FILES.get("file")		
        print(type(obj.name), obj.name)
        file_path = os.path.join("upload", obj.name)
        with open(file_path, mode="wb") as f:
            for part in obj.chunks():
                f.write(part)



